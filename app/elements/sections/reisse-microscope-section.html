<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../nvd3-toolbar/nvd3-toolbar.html">
<link rel="import" href="../reisse-event/reisse-event.html">

<dom-module id="reisse-microscope-section">
  <template>
    <style>
      :host { display: block; }
      :host .pool-item .feature-summary { white-space: pre-line; padding-left: 2em; }
    </style>
    <h1> Occurrences Predictions Analyzer </h1>

    <div>
      <h2>Prediction</h2>
      <template is="dom-if" if="[[context]]" restamp>
        <div class="context">
          <h3> Context </h3>

          <p>Now     : [[context.calendar.now]]</p>
          <p>Location: [[context.location.latitude]] lat, [[context.location.longitude]] lon</p>
          <p>
            People  :
            <template is="dom-repeat" items="[[context.people]]" as="person">
              <template is="dom-repeat" items="[[person.names]]" as="name">
                <span>[[name]]</span>
              </template>
            </template>
          </p>
          <p>Sleepiness: [[context.sleepiness]]</p>
          <p>
            Tools  :
            <template is="dom-repeat" items="[[context.tools]]" as="tool">
              <span>Name: [[tool.name]]</span>
              <span>Type: [[tool.type]]</span>
            </template>
          </p>

        </div>

      </template>

      <h3> Prediction Data </h3>

      <nvd3-toolbar for="prediction-data-chart" data="[[_behavioralData]]" filter-logic="point.occurrences[0].provider.name">
        <paper-input class="controls-content" label="Select prediction index" type="number" value="{{predictionIndex}}"></paper-input>
        <paper-item class="sorting-path-option" name="occurrence.0.features.chance.actual">Actual Chance</paper-item>
        <paper-item class="sorting-path-option" name="occurrence.0.features.chance.estimated">Estimated Chance</paper-item>
      </nvd3-toolbar>
      <nvd3-scatter id="prediction-data-chart" height="600" show-legend auto-resize></nvd3-scatter>

    </div>

    <reisse-predictions-section></reisse-predictions-section>

    <div>

      <h2> Occurence Microscope </h2>

      <paper-material elevation="1" style="padding: 1em;">

        <h3> Query ocurrence from prediction </h3>

        <paper-input label="Search for occurrence" type="text" value="{{query}}" on-keydown="_handleSearchInputKeyDown" title="Presse 'Enter' to add and 'Delete' to remove from pool"></paper-input>

        <template is="dom-if" if="[[matchingOccurrence]]" restamp>
          <span># [[matchingOccurrence.index]]</span>
          <reisse-event event="[[matchingOccurrence]]"></reisse-event>
        </template>

      </paper-material>

      <paper-input id="observed-features-input" label="Features" type="text" value="{{observedFeatures}}" title="Comma separated list of values"></paper-input>

      <table>
        <tr>
          <th>Occurrence</th>
          <template is="dom-repeat" items="[[pool.observedFeatures]]" as="feature">
            <th>[[feature]]</th>
          </template>
        </tr>

        <template is="dom-repeat" items="[[pool]]" as="occurrence" observe="observedFeatures">
          <tr>
            <td><reisse-event event="[[occurrence]]"></reisse-event></td>

            <template is="dom-repeat" items="[[occurrence.observedFeatures]]" as="feature">
              <td>
                <p title="Estimated">E: [[_computeFeatureAspect(occurrence, feature, 'estimated')]]</p>
                <p title="Actual">A: [[_computeFeatureAspect(occurrence, feature, 'actual')]]</p>
              </td>
            </template>
          </tr>
        </template>
      </table>

    </div>


  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'reisse-microscope-section',

      properties: {
        occurrences: Array,
        context: Object,

        pool: {
          type: Array,
          value() {return [];}
        },

        matchingOccurrence: {
          type: Object,
          computed: '_computeMatchingOcurrence(query, occurrences, pool)'
        },

        query: {
          type: String,
        },

        observedFeatures: {
          type: String,
          value: 'chance, simplicity, motivation, time, duration, brainCycles'
        },
      },

      observers: [
        '_observedFeaturesReactor(observedFeatures, pool)',
        '_applyPredictionIndex(predictionIndex)',
        '_renderBehaviorModel(occurrences)',
      ],

      _computeMatchingOcurrence(query, occurrences, pool) {
        if (occurrences === undefined) return undefined;
        if (query === undefined) return undefined;
        if (pool === undefined) return undefined;
        if (query === '') return undefined;

        const matcher = new RegExp(query, 'i'),
          fields = ['__firebaseKey__', 'name', 'provider.name'];

        const match = occurrences.find((occurrence, index) =>
          (
            fields.some((field) => matcher.test(_.get(occurrence, field))) ||
            matcher.test(index)
          ) &&
          !pool.includes(occurrence)
        );

        return Object.assign({index: occurrences.indexOf(match)}, match);
      },

      _handleSearchInputKeyDown({key}) {
        if (!['Enter', 'Delete'].includes(key)) return;
        if (!this.matchingOccurrence) {
          return this._log(this._logf('_handleSearchInputKeyDown', 'no matching occurrence to perform action!'));
        }

        switch (key) {
          case 'Enter':
            if (this.pool.includes(this.matchingOccurrence)) {
              return this._log(this._logf('_handleSearchInputKeyDown', 'occurrence already in pool.'));
            }
            return this.push('pool', this.matchingOccurrence);
          case 'Delete':
            if (!this.pool.includes(this.matchingOccurrence)) {
              return this._log(this._logf('_handleSearchInputKeyDown', 'occurrence not in pool.'));
            }
            return this.arrayDelete('pool', this.matchingOccurrence);
          default:
            this._log(this._logf('_handleSearchInputKeyDown', `invalid key for handling: ${key}`));
            break;
        }
      },

      _computeFeatureAspect(occurrence, name, aspect) {
        const feature = occurrence.features[name];
        if (!feature) return `Invalid name or inexistent feature with name: '${name}'.`;
        return (feature[aspect] || NaN).toFixed(8);
      },

      _observedFeaturesReactor(features, occurrences) {
        if (features === undefined) return undefined;
        if (occurrences === undefined) return undefined;
        const splitted = features.split(',').map((s) => s.trim());

        occurrences.forEach((_, index) => {
          this.notifyPath(['pool', 'observedFeatures'], splitted);
          this.notifyPath(['pool', index, 'observedFeatures'], splitted);
        });
      },

      _applyPredictionIndex(index) {
        if (index === "") return;
        index = parseInt(index);

        if (Re.predictions.length === 0) {
          return this._log(this._logf('_applyPredictionIndex', `predictions not made yet!`));
        }

        const prediction = Re.predictions[index];
        if (!Re.predictions[index]) {
          this._log(this._logf('_applyPredictionIndex', `index too big, max value: ${Re.predictions.length}.`));
        }

        this.occurrences = prediction[0];
        this.context = prediction[1];
        this.$["observed-features-input"].placeholder = _.map(Feature.all(), 'name').join(', ');
        this.$["observed-features-input"].title = _.map(Feature.all(), 'name').join(', ');
      },

      _renderBehaviorModel(occurrences) {
        const chart = this.$['prediction-data-chart'], model = chart._chart;
        const {xAxis, yAxis, tooltip} = model;
        const colors = _(occurrences)
          .map('provider.name')
          .uniq()
          .zip(d3.scale.category20().range())
          .fromPairs()
          .value();

        const data = this.__createBehaviorModelScatterData(occurrences, colors);

        xAxis.axisLabel('Simplicity');
        xAxis.tickFormat((x) => x.toFixed(4));
        yAxis.axisLabel('Motivation');
        yAxis.tickFormat((y) => y.toFixed(4));

        const prediction = occurrences;
        tooltip.contentGenerator(({point: {x, y, occurrences, color}, series: [serie]}) => {
          let output = `<p style="border-bottom: 2px solid ${color}">
            ${serie.key} Simplicity: ${xAxis.tickFormat()(x)} <br />
            ${serie.key} Motivation: ${yAxis.tickFormat()(y)} <br />
          </p>`;

          app.highlightedBehaviors = occurrences;

          output += occurrences
            .slice(0, 10)
            .reduce((accumulator, occurrence) => {
              const {name, provider} = occurrence;
              const index = prediction.indexOf(occurrence);
              return accumulator + `<p>#${index} (${provider.name}) - ${name}</p>`;
            }, '');

          output += `<p><br />Total Behaviors: ${occurrences.length}</p>`;
          return `<div style="padding: 0.5em; text-align: left;">${output}</div>`;
        });

        chart.generateChart();

        this._behavioralData = data;

        if (!_.isFunction(model.container)) {
          d3.select(model.container)
            .selectAll('.nv-point')
            .style('fill', (d) => d[0].color)
            .style('stroke', (d) => d[0].color);
        }
      },

      __createBehaviorModelScatterData(occurrences, colors) {
        return _(occurrences)
          // Create series
          .map((occurrence, index) => {
            const {features: {simplicity, motivation}} = occurrence;
            return [{
              occurrence,
              kind: 'actual',
              x: simplicity.actual || 0, y: motivation.actual || 0
            }, {
              occurrence,
              kind: 'estimated',
              x: simplicity.estimated || 0, y: motivation.estimated || 0
            }];
          })
          .flatten()
          // Limits Y precision
          .map((value) => Object.assign(value, { y: parseFloat(value.y.toFixed(10)) }))
          .groupBy('kind')
          .map((group, index) => {

            const values = _(group)
              .groupBy('y')
              .map((subgroup) => ({
                x: subgroup[0].x, y: parseFloat(subgroup[0].y),
                size: subgroup.length,
                occurrences: subgroup.map(({occurrence}) => occurrence),
                color: colors[subgroup[0].occurrence.provider.name]
              }))
              .value()

            return {key: _.upperFirst(group[0].kind), values};
          })
          .value();
      }
    });
  })();
  </script>
</dom-module>
