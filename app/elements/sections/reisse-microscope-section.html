<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../reisse-event/reisse-event.html">

<dom-module id="reisse-microscope-section">
  <template>
    <style>
      :host { display: block; }
      :host .pool-item .feature-summary { white-space: pre-line; padding-left: 2em; }
    </style>
    <h1> Occurrences Microscope Analysis </h1>

    <template is="dom-if" if="[[context]]" restamp>
      <div class="context">
        <h2> Context </h2>

        <p>Now     : [[context.calendar.now]]</p>
        <p>Location: [[context.location.latitude]] lat, [[context.location.longitude]] lon</p>
        <p>
          People  :
          <template is="dom-repeat" items="[[context.people]]" as="person">
            <template is="dom-repeat" items="[[person.names]]" as="name">
              <span>[[name]]</span>
            </template>
          </template>
        </p>
        <p>Sleepiness: [[context.sleepiness]]</p>
        <p>
          Tools  :
          <template is="dom-repeat" items="[[context.tools]]" as="tool">
            <span>Name: [[tool.name]]</span>
            <span>Type: [[tool.type]]</span>
          </template>
        </p>

      </div>

    </template>

    <h2> Prediction </h2>

    <div class="horizontal layout">
      <paper-input label="Select prediction index" type="number" value="{{predictionIndex}}"></paper-input>
      <paper-input step="0.1" type="number" value="{{chartOptions.domains.x.start}}" label="X Domain Start"></paper-input>
      <paper-input step="0.1" type="number" value="{{chartOptions.domains.x.end}}" label="X Domain End"></paper-input>
      <paper-input step="0.1" type="number" value="{{chartOptions.domains.y.start}}" label="Y Domain Start"></paper-input>
      <paper-input step="0.1" type="number" value="{{chartOptions.domains.y.end}}" label="Y Domain End"></paper-input>
    </div>

    <nvd3-scatter id="chart" height="600" show-legend auto-resize stop-auto-drawing></nvd3-scatter>

    <h2> Occurence Pool </h2>

    <paper-material elevation="1" style="padding: 1em;">

      <h3> Query ocurrence from prediction </h3>

      <paper-input label="Search for occurrence" type="text" value="{{query}}" on-keydown="_handleSearchInputKeyDown" title="Presse 'Enter' to add and 'Delete' to remove from pool"></paper-input>

      <template is="dom-if" if="[[matchingOccurrence]]" restamp>
        <span># [[matchingOccurrence.index]]</span>
        <reisse-event event="[[matchingOccurrence]]"></reisse-event>
      </template>

    </paper-material>

    <paper-input id="observed-featuers-input" label="Features" type="text" value="{{observedFeatures}}" title="Comma separated list of values"></paper-input>

    <table>
      <tr>
        <th>Occurrence</th>
        <template is="dom-repeat" items="[[pool.observedFeatures]]" as="feature">
          <th>[[feature]]</th>
        </template>
      </tr>

      <template is="dom-repeat" items="[[pool]]" as="occurrence" observe="observedFeatures">
        <tr>
          <td><reisse-event event="[[occurrence]]"></reisse-event></td>

          <template is="dom-repeat" items="[[occurrence.observedFeatures]]" as="feature">
            <td>
              <p title="Estimated">E: [[_computeFeatureAspect(occurrence, feature, 'estimated')]]</p>
              <p title="Actual">A: [[_computeFeatureAspect(occurrence, feature, 'actual')]]</p>
            </td>
          </template>
        </tr>
      </template>
    </table>

  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'reisse-microscope-section',

      properties: {
        occurrences: Array,
        context: Object,

        pool: {
          type: Array,
          value() {return [];}
        },

        matchingOccurrence: {
          type: Object,
          computed: '_computeMatchingOcurrence(query, occurrences, pool)'
        },

        query: {
          type: String,
        },

        observedFeatures: {
          type: String,
          value: 'chance, simplicity, motivation, time, duration, brainCycles'
        },

        chartOptions: {
          type: Object,
          value() {
            const range = {start: 0, end: 0};
            return {domains: {x: range, y: Object.assign({}, range)}};}
        }
      },

      observers: [
        '_observedFeaturesReactor(observedFeatures, pool)',
        '_applyPredictionIndex(predictionIndex)',
        '_renderFoggModel(occurrences)'
      ],

      _computeMatchingOcurrence(query, occurrences, pool) {
        if (occurrences === undefined) return undefined;
        if (query === undefined) return undefined;
        if (pool === undefined) return undefined;
        if (query === '') return undefined;

        const matcher = new RegExp(query, 'i'),
          fields = ['__firebaseKey__', 'name', 'provider.name'];

        const match = occurrences.find((occurrence, index) =>
          (
            fields.some((field) => matcher.test(_.get(occurrence, field))) ||
            matcher.test(index)
          ) &&
          !pool.includes(occurrence)
        );

        return Object.assign({index: occurrences.indexOf(match)}, match);
      },

      _handleSearchInputKeyDown({key}) {
        if (!['Enter', 'Delete'].includes(key)) return;
        if (!this.matchingOccurrence) {
          return this._log(this._logf('_handleSearchInputKeyDown', 'no matching occurrence to perform action!'));
        }

        switch (key) {
          case 'Enter':
            if (this.pool.includes(this.matchingOccurrence)) {
              return this._log(this._logf('_handleSearchInputKeyDown', 'occurrence already in pool.'));
            }
            return this.push('pool', this.matchingOccurrence);
          case 'Delete':
            if (!this.pool.includes(this.matchingOccurrence)) {
              return this._log(this._logf('_handleSearchInputKeyDown', 'occurrence not in pool.'));
            }
            return this.arrayDelete('pool', this.matchingOccurrence);
          default:
            this._log(this._logf('_handleSearchInputKeyDown', `invalid key for handling: ${key}`));
            break;
        }
      },

      _computeFeatureAspect(occurrence, name, aspect) {
        const feature = occurrence.features[name];
        if (!feature) return `Invalid name or inexistent feature with name: '${name}'.`;
        return (feature[aspect] || NaN).toFixed(8);
      },

      _observedFeaturesReactor(features, occurrences) {
        if (features === undefined) return undefined;
        if (occurrences === undefined) return undefined;
        const splitted = features.split(',').map((s) => s.trim());

        occurrences.forEach((_, index) => {
          this.notifyPath(['pool', 'observedFeatures'], splitted);
          this.notifyPath(['pool', index, 'observedFeatures'], splitted);
        });
      },

      _applyPredictionIndex(index) {
        if (index === "") return;
        index = parseInt(index);

        if (Re.predictions.length === 0) {
          return this._log(this._logf('_applyPredictionIndex', `predictions not made yet!`));
        }

        const prediction = Re.predictions[index];
        if (!Re.predictions[index]) {
          this._log(this._logf('_applyPredictionIndex', `index too big, max value: ${Re.predictions.length}.`));
        }

        this.occurrences = prediction[0];
        this.context = prediction[1];
        this.$["observed-featuers-input"].placeholder = _.map(Feature.all(), 'name').join(', ');
        this.$["observed-featuers-input"].title = _.map(Feature.all(), 'name').join(', ');
      },

      _renderFoggModel(occurrences, options) {
        const {chart} = this.$, model = chart._chart;
        const {xAxis, yAxis, xDomain, yDomain, tooltip} = model;
        const data = _(occurrences)
          .map((occurrence, index) => {
            const {features: {simplicity, motivation}} = occurrence;
            return [{
              occurrence,
              kind: 'actual',
              x: simplicity.actual || 0, y: motivation.actual || 0
            }, {
              occurrence,
              kind: 'estimated',
              x: simplicity.estimated || 0, y: motivation.estimated || 0
            }];
          })
          .flatten()
          .map((value) => Object.assign(value, { y: parseFloat(value.y.toFixed(10)) }))
          .groupBy('kind')
          .map((group, index) => {
            const values = _(group)
              .groupBy('y')
              .map((subgroup) => ({
                x: subgroup[0].x, y: parseFloat(subgroup[0].y),
                size: subgroup.length,
                occurrences: subgroup.map(({occurrence}) => occurrence)
              }))
              .value()

            return {key: _.upperFirst(group[0].kind), values};
          })
          .value();

        xAxis.axisLabel('Simplicity');
        xAxis.tickFormat((y) => y.toFixed(4));
        xDomain([0, 1]);
        yAxis.axisLabel('Motivation');
        yAxis.tickFormat((y) => y.toFixed(4));
        yDomain([0, 1]);

        tooltip.contentGenerator(({point: {x, y, occurrences}, series: [serie]}) => {
          let output = `<p style="border-bottom: 2px solid ${serie.color}">
            ${serie.key} Simplicity: ${xAxis.tickFormat()(x)} <br />
            ${serie.key} Motivation: ${yAxis.tickFormat()(y)} <br />
            Motivation + Simplicity: ${xAxis.tickFormat()(x + y)}
          </p>`;

          app.highlightedBehaviors = occurrences;

          output += occurrences
            .slice(0, 10)
            .reduce((accumulator, {name}) =>  accumulator + `<p>${name}</p>`, '')

          output += `<p><br />Total Behaviors: ${occurrences.length}</p>`;
          return `<div style="padding: 0.5em; text-align: left;">${output}</div>`;
        });
        chart.data = data;
        chart.generateChart();
      }

    });
  })();
  </script>
</dom-module>
