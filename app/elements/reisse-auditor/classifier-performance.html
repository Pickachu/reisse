<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/nvd3-elements/nvd3-multi-bar.html">
<link rel="import" href="../../bower_components/nvd3-elements/nvd3-multi-bar-horizontal.html">
<link rel="import" href="../../bower_components/nvd3-elements/nvd3-scatter.html">
<link rel="import" href="../../bower_components/nvd3-elements/nvd3-candle-stick-bar.html">

<link rel="import" href="../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">

<link rel="import" href="../nvd3-toolbar/nvd3-toolbar.html">

<dom-module id="classifier-performance">
  <style>
    :host { display: block; }
    paper-material {
      padding: 1em;
    }
  </style>
  <template>
    <header>
      <h2 on-tap="_collapse">[[meta.title]]</h2>

      <paper-material>
        <paper-button toggles active="{{_displayChartControls}}">Chart controls</paper-button>
        <paper-button toggles active="{{_displayTrainingControls}}">Training controls</paper-button>
        <iron-collapse opened="{{_displayChartControls}}">
          <div class="horizontal layout">
            <paper-input type="number" value="{{_domains.x.start}}" label="X Domain Start"></paper-input>
            &nbsp;
            <paper-input type="number" value="{{_domains.x.end}}" label="X Domain End"></paper-input>
            <br />
            <paper-input type="number" value="{{_domains.y.start}}" label="Y Domain Start"></paper-input>
            &nbsp;
            <paper-input type="number" value="{{_domains.y.end}}" label="Y Domain End"></paper-input>
          </div>
        </iron-collapse>
        <iron-collapse opened="{{_displayTrainingControls}}">
          <template is="dom-if" if="[[meta.classifier]]">
            <p class="horizontal layout">
              <p>Classifier Type: [[meta.classifier.constructor.name]]</p>
              <p>Layers:</p>
              <p>Input: Size: [[meta.classifier.layers.input.size]]</p>
              <template is="dom-repeat" items="[[meta.classifier.layers.hidden]]" as="layer">
                <p>Hidden #[[index]]: Size: [[layer.size]]</p>
              </template>
              <p>Output: Size: [[meta.classifier.layers.output.size]]</p>
            </p>
          </template>

          <template is="dom-if" if="[[meta.context]]" restamp>
            <div class="context">
              <h2> Context </h2>

              <p>Now     : [[meta.context.calendar.now]]</p>
              <p>Location: [[meta.context.location.latitude]] lat, [[meta.context.location.longitude]] lon</p>
              <p>
                People  :
                <template is="dom-repeat" items="[[meta.context.people]]" as="person">
                  <template is="dom-repeat" items="[[person.names]]" as="name">
                    <span>[[name]]</span>
                  </template>
                </template>
              </p>
              <p>
                Tools  :
                <template is="dom-repeat" items="[[meta.context.tools]]" as="tool">
                  <span>Name: [[tool.name]]</span>
                  <span>Type: [[tool.type]]</span>
                </template>
              </p>

            </div>

          </template>

          <template is="dom-if" if="[[meta.training]]">
            <p class="layout horizontal">
              <paper-input type="number" value="{{meta.training.iterations}}" step="25" label="Iterations"></paper-input>
              <paper-input type="number" value="{{meta.training.rate}}" step="0.01" label="Learning rate"></paper-input>
            </p>
          </template>

          <!-- TODO update all implementations to use meta.training -->
          <template is="dom-if" if="[[!meta.training]]">
            <p class="layout horizontal">
              <paper-input type="number" value="{{meta.iterations}}" label="Iterations"></paper-input>
              <paper-input type="number" value="{{meta.rate}}" step="0.01" label="Learning rate"></paper-input>
            </p>
          </template>

          <template is="dom-if" if="[[meta.classifier]]">
            <nvd3-toolbar id="learning-toolbar" for="learning-chart" data="[[learningData]]">
              <paper-dropdown-menu class="controls-content" label="Focus on neuron activations" title="Overrides default dataset to a ficticious dataset">
                <paper-listbox selected="{{investigatedSerie}}" attr-for-selected="name" class="dropdown-content">
                  <paper-item name="original-serie">None</paper-item>
                  <template is="dom-repeat" items="{{investigableSeries}}" as="serie">
                    <paper-item name="[[serie.key]]">[[serie.key]]</paper-item>
                  </template>
                </paper-listbox>
              </paper-dropdown-menu>

            </nvd3-toolbar>
            <nvd3-scatter id="learning-chart" height="600" show-legend auto-resize></nvd3-scatter>
          </template>
          <p>Error: [[meta.error]] Time: [[meta.trainingTime]] Sample Size: [[meta.sampleSize]]</p>
          <paper-button on-tap="_retrain">Retrain</paper-button>
        </iron-collapse>
      </paper-material>
    </header>

    <section id="graph">
      <template is="dom-if" if="[[_eq(type, 'scatter')]]">
        <nvd3-scatter id="performance-chart" height="600" show-legend auto-resize stop-auto-drawing></nvd3-scatter>
      </template>
      <template is="dom-if" if="[[_eq(type, 'multi-bar')]]">
        <nvd3-multi-bar id="performance-chart" height="600" show-legend auto-resize stop-auto-drawing></nvd3-multi-bar>
      </template>
      <template is="dom-if" if="[[_eq(type, 'multi-bar-horizontal')]]">
        <nvd3-multi-bar-horizontal id="performance-chart" height="600" show-legend auto-resize stop-auto-drawing></nvd3-multi-bar-horizontal>
      </template>
      <template is="dom-if" if="[[_eq(type, 'candle-stick-bar')]]">
        <nvd3-candle-stick-bar id="performance-chart" height="600" show-legend auto-resize stop-auto-drawing></nvd3-candle-stick-bar>
      </template>
    </section>
  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'classifier-performance',

      properties: {
        type: {
          type: String,
          value: 'multi-bar'
        },
        meta: Object,
        data: Object,

        // TODO remove domains, and use toolbar for default chart
        _domains: {
          type: Object,
          value() {return {x: {}, y: {}}}
        },

        _perfomanceGraphReady: {
          type: Boolean,
          value: false
        },

        learningData: {
          type: Object,
          computed: '__computeLearningData(meta.classifier, meta.set, investigatedSerie)'
        },

        investigatedSerie: {
          type: String,
          value: 'original-serie'
        },

        investigableSeries: {
          type: Object,
          // ! TODO implement, and investigate chance correlations
          computed: '__computeInvestigableSeries(meta.set)'
        },

        _learningGraphReady: {
          type: Boolean,
          value: false
        },
      },

      observers: [
        '_redraw(data, _perfomanceGraphReady, _domains.*)',
        '_redrawNetworkTraining(meta.classifier, meta.set, _learningGraphReady, _displayTrainingControls)'
      ],

      listeners: {
        'dom-change': '_handleChartsAttachement'
      },

      _redraw(data, graphReady) {
        if (!graphReady) return;

        const chart = this.$$('#performance-chart'), model = chart._chart;

        if (chart.data != data) {
          chart.data = data;
          chart.generateChart();
        }

        if (model.useInteractiveGuideline) {
          model.useInteractiveGuideline(true);
        }

        model.stacked && model.stacked(true);

        if (this.meta && this.meta.options) {
          this._applyOptions(this.meta.options, model, chart)
        }

        this._applyDomain(model, this._domains, chart, 'x');
        this._applyDomain(model, this._domains, chart, 'y');

        model.update && model.update();
      },

      _eq (a, b) {
        return a === b;
      },

      _handleChartsAttachement() {
        this._perfomanceGraphReady = !!this.$$('#performance-chart');
        this._learningGraphReady = !!this.$$('#learning-chart');
      },

      _applyDomain(model, domains, chart, name, redraw = true) {
        const {start, end} = domains[name];
        if (isFinite(+start) && isFinite(+end) && +start < +end) {

          // FIXME figure out how to use nvd3 api to filter multibar charts
          if (this.type === 'multi-bar') {
            chart.data = this.data.map((series) =>
              Object.assign({}, series, {
                values: series.values.slice(+start, +end)
              })
            );
            redraw && chart.generateChart();
          } else {
            model[`${name}Domain`]([+start, +end]);
          }
        }
      },

      _applyOptions(options, model, chart) {
        if (typeof options === 'function') return options(model, chart);

        if (options.axis) {
          if (options.axis.x) {
            model.xAxis.options(options.axis.x);
          }
          if (options.axis.y) {
            model.yAxis.options(options.axis.y);
          }
        }

        if (options.domains) {
          if (options.domains.y) {
            model.yDomain(options.domains.y);
          }
        }

        if (options.configure) {
          options.configure(model, chart);
        }
      },

      _retrain () {
        if (this.meta.training) {this.meta.training.rate = parseFloat(this.meta.training.rate);}
        this.fire('request-performance-retrain', {meta: this.meta});
      },

      __computeLearningData(classifier, set, key) {
        if (!classifier) return;
        if (!set) return;

        const series = this.__createSeries(classifier);

        if (key == 'original-serie') {
          return this.__createSetBasedData(set, classifier, series);
        } else {
          return this.__createNeuronActivationBasedData(key, classifier, series);
        }
      },

      _redrawNetworkTraining(learningData, ready, active) {
        if (!ready) return;
        if (!active) return;

        this.debounce('redraw-network-training', () => {
          // this.learningData = learningData;
        });
      },

      __createSeries({layers}) {
        return [].concat(
          layers.input.list.map((neuron, index) => ({
            key: neuron.label || `Input #${index}`,
            values: []
          }))
        ).concat(
          layers.output.list.map((neuron, index) => ({
            key: neuron.label || `Output #${index}`,
            values: []
          }))
        ).concat(
          layers.output.list.map((neuron, index) => ({
            key: `Predicted ${neuron.label}` || `Prediction #${index}`,
            values: []
          }))
        );
      },

      __createNeuronActivationBasedData(key, classifier, series) {
        const range = d3.range(0, 1.1, 0.1),
        combinations = ss.combinationsReplacement(range, series.length);

        series.sort((a, b) => {
          if (a.key === key) return -1;
          else if (b.key === key) return 1;
          else return 0;
        });

        return series.forEach((serie, index) => {
          return Object.assign(serie, {
            values: combinations.map((combination, x) => ({x, y: combination[index]}))
          });
        });

      },
      __createSetBasedData(set, classifier, series) {
        return set
          .reduce((series, {input, output}, x) => {

            const offset = input.length + output.length;
            input.concat(output).forEach((activation, serie) => {
              series[serie].values.push({y: activation, x});
            });

            const prediction = classifier.activate(input);
            prediction.forEach((activation, index) => {
              series[index + offset].values.push({y: activation, x});
            });

            return series;
          }, series);
      },

      _collapse() {
        this.$.graph.classList.toggle('hidden');
      },

      __computeInvestigableSeries(set) {
        return [];
      }
    });
  })();
  </script>
</dom-module>
