'use strict';

const aggregable = function (instance, {name, feature, value: current, onWrite}) {
    const optimize = Feature.optimize.bind(Feature);

    Object.defineProperty(instance, name, {
        enumerable: true,
        configurable: true,
        get () {return current;},
        set (value) {
            if (_.isNaN(value)) throw new TypeError("Feature.<aggregable>: Can't set feature value to NaN!");
            onWrite && onWrite.call(this, value, current);
            current = value;
            optimize(feature + '_' + name, current);
            return current;
        }
    });

    instance[name] = current;
},


/**
 * A predictive feature for this ocurrence.
 *
 * It has various values associeted with it:
 *
 * • The relative value: Value relative to same feature in other occurrence
 *
 * • The predicted value:
 *    Generally predicted by classifiers.
 *    It is stored in the estimated field.
 *
 *    This is a value that is generated by the Relissë application based on various
 *    (context and other behaviors) informations given to a predictor
 *
 * • The actual value:
 *    Generally defined by the estimators.
 *
 *    This is a value that is measured by measurement tools (personal trackers,
 *    applications, web-api's) or inferred with really high confidence (90%+)
 *    from data measured by the measurement tools.
 *
 *    - Non-Relissë features estimators have actual values inferred matematically
 *    - Relissë conceptual behavior model features have actual values predicted
 *    by estimators (using classifiers)
 *
 * • The truer value: Value more close to the truth for this feature
 *
 * @type {Feature}
 */
Feature = stampit({
    init () {
        aggregable(this, {
          name: 'relative',
          feature: this.name,
          value: this.relative,
        });
        // TODO rename estimated to predicted
        aggregable(this, {
          name: 'estimated',
          feature: this.name,
          value: this.estimated,
          onWrite(value) { this.truer = isFinite(this.actual) ? this.actual : value; }
        });
        aggregable(this, {
          name: 'actual',
          feature: this.name,
          value: this.actual,
          onWrite(value) { this.truer = isFinite(value) ? value : this.estimated; }
        });
        aggregable(this, {
          name: 'truer',
          feature: this.name,
          value: isFinite(this.actual) ? this.actual : this.estimated,
        });

        // FIXME Clean feature to preserve the JSON structure accepted by firebase
        //       do cleaning on serialization!
        // _.forEach(this, (value, key) => {_.isUndefined(value) && delete this[key]})

        // Feature.store(this.name, this);
        Feature.summaries(this.name);
        Feature.increment(this.name);
    },
    methods: {
        toJSON () {
            // Return serialized version of only non undefined values
            return _.pickBy(_.omit(this, _.functions(this)), _.negate(_.isUndefined));
        }
    },
    static: {
        instances: {},
        aggregates: {maximums: {}, minimums: {}},
        counts: {},
        all() {
          return Object.entries(this.counts)
            .map(([name, count]) => ({ name, count }));
        },
        many (source) {
            let names = [].slice.call(arguments, 1, arguments.length), features = {};
            source.features || (source.features = {});

            names.forEach((name) => {
                let feature = source.features[name] || {name: name};
                feature.name || (feature.name = name);
                features[name]   = Feature(feature);
                // TODO
                // features.__proto__.incorporate = () => {source.incorporate.apply(source, arguments);};
            }, this);

            return features;
        },
        store (name, instance) {
            this.instances[name] = this.instances[name] || [];
            this.instances[name].push(instance);
        },
        summaries (name) {
            // Summaries are created once per feature name, so skip existent features
            if (Number.isFinite(this.counts[name])) return;

            let maximums = this.aggregates.maximums, minimums = this.aggregates.minimums;
            this.counts[name] = 0;

            ['relative', 'estimated', 'actual', 'truer'].forEach((property) => {
                maximums[name + '_' + property] = 1
                minimums[name + '_' + property] = 0
            });
        },
        increment (name) {
            this.counts[name]++;
        },
        optimize (name, value) {
            let maximums = this.aggregates.maximums, minimums = this.aggregates.minimums;
            if (maximums[name] < value) {maximums[name] = value;}
            if (minimums[name] > value) {minimums[name] = value;}
        },
        _findRelativeFeature (comparator, name) {
            return Feature.instances[name].find((feature, index) => {
                // Ignore features that does not have a numerical value
                if (!Number.isFinite(feature.relative)) return false;

                // Found other feature ?
                return comparator(feature);
            });
        }
    }
});
